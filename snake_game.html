<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤ë„¤ì´í¬ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .left-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: white;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        #gameCanvas {
            border: 4px solid white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        #score {
            color: white;
            font-size: 20px;
            margin-top: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        #highScore {
            color: #ffd43b;
            font-size: 16px;
            margin-top: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .new-record {
            color: #ffd43b;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #instructions {
            color: white;
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        .game-over h2 {
            margin-top: 0;
            color: #ff6b6b;
        }

        .game-over button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 16px;
            background: #51cf66;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .game-over button:hover {
            background: #40c057;
        }

        .ranking-panel {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        .ranking-panel h2 {
            color: white;
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .ranking-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .ranking-item {
            background: rgba(255, 255, 255, 0.15);
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            transition: transform 0.2s;
        }

        .ranking-item:hover {
            transform: translateX(5px);
            background: rgba(255, 255, 255, 0.2);
        }

        .ranking-item.rank-1 {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .ranking-item.rank-2 {
            background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%);
            color: #333;
            font-weight: bold;
        }

        .ranking-item.rank-3 {
            background: linear-gradient(135deg, #cd7f32 0%, #e8a87c 100%);
            color: #333;
            font-weight: bold;
        }

        .rank-number {
            font-size: 18px;
            font-weight: bold;
            margin-right: 10px;
        }

        .rank-score {
            font-size: 18px;
            font-weight: bold;
        }

        .rank-date {
            font-size: 11px;
            opacity: 0.8;
            margin-left: 8px;
        }

        .clear-ranking-btn {
            width: 100%;
            margin-top: 15px;
            padding: 8px;
            background: rgba(255, 107, 107, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .clear-ranking-btn:hover {
            background: rgba(255, 107, 107, 1);
        }
    </style>
</head>
<body>
    <h1>ğŸ ìŠ¤ë„¤ì´í¬ ê²Œì„</h1>

    <div class="game-container">
        <div class="left-section">
            <div id="score">ì ìˆ˜: 0</div>
            <div id="highScore">ìµœê³  ì ìˆ˜: 0</div>
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div id="instructions">
                ë°©í–¥í‚¤ë¡œ ì´ë™í•˜ì„¸ìš” | ë¹¨ê°„ ì‚¬ê³¼ë¥¼ ë¨¹ìœ¼ì„¸ìš”!
            </div>
        </div>

        <div class="ranking-panel">
            <h2>ğŸ† TOP 5 ë­í‚¹</h2>
            <ol class="ranking-list" id="rankingList">
            </ol>
            <button class="clear-ranking-btn" onclick="clearRanking()">ë­í‚¹ ì´ˆê¸°í™”</button>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>ê²Œì„ ì˜¤ë²„!</h2>
        <p id="finalScore"></p>
        <button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const rankingListElement = document.getElementById('rankingList');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let snake = [
            {x: 10, y: 10}
        ];
        let velocity = {x: 0, y: 0};
        let food = {x: 15, y: 15};
        let score = 0;
        let highScore = 0;
        let gameRunning = false;
        let gameLoop;
        let rankings = [];
        let isGameOver = false;

        // API ì„œë²„ URL
        const API_URL = 'http://localhost:3333/api';

        // ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadRankings() {
            try {
                const response = await fetch(`${API_URL}/rankings`);
                if (!response.ok) throw new Error('ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜');

                rankings = await response.json();
                updateRankingDisplay();

                highScore = rankings.length > 0 ? rankings[0].score : 0;
                highScoreElement.textContent = 'ìµœê³  ì ìˆ˜: ' + highScore;
            } catch (error) {
                console.error('ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                rankings = [];
                updateRankingDisplay();
            }
        }

        // ë­í‚¹ ì €ì¥í•˜ê¸°
        async function saveRanking(newScore) {
            const now = new Date();
            const dateStr = `${now.getMonth() + 1}/${now.getDate()} ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
            const timestamp = now.getTime();

            try {
                const response = await fetch(`${API_URL}/rankings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        score: newScore,
                        date: dateStr,
                        timestamp: timestamp
                    })
                });

                if (!response.ok) throw new Error('ì €ì¥ ì‹¤íŒ¨');

                await loadRankings();
            } catch (error) {
                console.error('ë­í‚¹ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
            }
        }

        // ë­í‚¹ í™”ë©´ ì—…ë°ì´íŠ¸
        function updateRankingDisplay() {
            rankingListElement.innerHTML = '';

            const top5 = rankings.slice(0, 5);

            if (top5.length === 0) {
                rankingListElement.innerHTML = '<li style="color: white; text-align: center; padding: 20px;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤</li>';
                return;
            }

            top5.forEach((record, index) => {
                const li = document.createElement('li');
                li.className = 'ranking-item';

                if (index === 0) li.classList.add('rank-1');
                else if (index === 1) li.classList.add('rank-2');
                else if (index === 2) li.classList.add('rank-3');

                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : '';

                li.innerHTML = `
                    <span>
                        <span class="rank-number">${medal} ${index + 1}ìœ„</span>
                        <span class="rank-date">${record.date}</span>
                    </span>
                    <span class="rank-score">${record.score}ì </span>
                `;

                rankingListElement.appendChild(li);
            });
        }

        // ë­í‚¹ ì´ˆê¸°í™”
        async function clearRanking() {
            if (confirm('ì •ë§ë¡œ ëª¨ë“  ë­í‚¹ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                try {
                    const response = await fetch(`${API_URL}/rankings`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) throw new Error('ì´ˆê¸°í™” ì‹¤íŒ¨');

                    rankings = [];
                    highScore = 0;
                    updateRankingDisplay();
                    highScoreElement.textContent = 'ìµœê³  ì ìˆ˜: 0';
                } catch (error) {
                    console.error('ë­í‚¹ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜:', error);
                }
            }
        }

        // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        document.addEventListener('keydown', keyPress);

        function keyPress(e) {
            const arrowKeys = ['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'];
            if (!gameRunning && !isGameOver && arrowKeys.includes(e.key)) {
                startGame();
            }

            switch(e.key) {
                case 'ArrowLeft': // ì™¼ìª½
                    if (velocity.x !== 1) {
                        velocity = {x: -1, y: 0};
                    }
                    break;
                case 'ArrowUp': // ìœ„
                    if (velocity.y !== 1) {
                        velocity = {x: 0, y: -1};
                    }
                    break;
                case 'ArrowRight': // ì˜¤ë¥¸ìª½
                    if (velocity.x !== -1) {
                        velocity = {x: 1, y: 0};
                    }
                    break;
                case 'ArrowDown': // ì•„ë˜
                    if (velocity.y !== -1) {
                        velocity = {x: 0, y: 1};
                    }
                    break;
            }
        }

        function startGame() {
            gameRunning = true;
            gameLoop = setInterval(update, 100);
        }

        function update() {
            // ë±€ ì´ë™
            const head = {x: snake[0].x + velocity.x, y: snake[0].y + velocity.y};

            // ë²½ ì¶©ëŒ ì²´í¬
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // ìê¸° ìì‹ ê³¼ ì¶©ëŒ ì²´í¬
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // ìŒì‹ ë¨¹ê¸°
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreElement.textContent = 'ì ìˆ˜: ' + score;
                generateFood();
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            // ë°°ê²½
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸° (ì„ íƒì )
            ctx.strokeStyle = '#2a2a3e';
            for (let i = 0; i < tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // ë±€ ê·¸ë¦¬ê¸°
            snake.forEach((segment, index) => {
                if (index === 0) {
                    // ë¨¸ë¦¬
                    ctx.fillStyle = '#51cf66';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // ë±€ ëˆˆ ì¶”ê°€
                    ctx.fillStyle = 'white';
                    const eyeSize = 3;

                    if (velocity.x === 1) { // ì˜¤ë¥¸ìª½
                        ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 12, eyeSize, eyeSize);
                    } else if (velocity.x === -1) { // ì™¼ìª½
                        ctx.fillRect(segment.x * gridSize + 5, segment.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(segment.x * gridSize + 5, segment.y * gridSize + 12, eyeSize, eyeSize);
                    } else if (velocity.y === -1) { // ìœ„
                        ctx.fillRect(segment.x * gridSize + 5, segment.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 5, eyeSize, eyeSize);
                    } else if (velocity.y === 1) { // ì•„ë˜
                        ctx.fillRect(segment.x * gridSize + 5, segment.y * gridSize + 12, eyeSize, eyeSize);
                        ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 12, eyeSize, eyeSize);
                    } else {
                        // ì •ì§€ ìƒíƒœ
                        ctx.fillRect(segment.x * gridSize + 6, segment.y * gridSize + 7, eyeSize, eyeSize);
                        ctx.fillRect(segment.x * gridSize + 11, segment.y * gridSize + 7, eyeSize, eyeSize);
                    }
                } else {
                    // ëª¸í†µ
                    ctx.fillStyle = '#40c057';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );
                }
            });

            // ìŒì‹ ê·¸ë¦¬ê¸° (ì‚¬ê³¼ ì´ëª¨ì§€)
            ctx.font = `${gridSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                'ğŸ',
                food.x * gridSize + gridSize / 2,
                food.y * gridSize + gridSize / 2
            );
        }

        function generateFood() {
            food.x = Math.floor(Math.random() * tileCount);
            food.y = Math.floor(Math.random() * tileCount);

            // ë±€ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸
            for (let segment of snake) {
                if (food.x === segment.x && food.y === segment.y) {
                    generateFood();
                    return;
                }
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            gameRunning = false;
            isGameOver = true;

            // ë­í‚¹ì— ì ìˆ˜ ì¶”ê°€
            if (score > 0) {
                const isNewRecord = score > highScore;
                saveRanking(score);

                let message = 'ìµœì¢… ì ìˆ˜: ' + score;
                if (isNewRecord) {
                    message = '<span class="new-record">ğŸ‰ ìƒˆë¡œìš´ ìµœê³  ê¸°ë¡! ğŸ‰</span><br>ìµœì¢… ì ìˆ˜: ' + score;
                }

                finalScoreElement.innerHTML = message;
            } else {
                finalScoreElement.innerHTML = 'ìµœì¢… ì ìˆ˜: 0';
            }

            gameOverElement.style.display = 'block';
        }

        function restartGame() {
            snake = [{x: 10, y: 10}];
            velocity = {x: 0, y: 0};
            food = {x: 15, y: 15};
            score = 0;
            scoreElement.textContent = 'ì ìˆ˜: 0';
            gameOverElement.style.display = 'none';
            gameRunning = false;
            isGameOver = false;
            draw();
        }

        // ì´ˆê¸°í™”
        (async () => {
            await loadRankings();
            draw();
        })();
    </script>
</body>
</html>